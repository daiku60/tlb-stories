{
    "componentChunkName": "component---src-lekoarts-gatsby-theme-minimal-blog-core-templates-post-query-tsx",
    "path": "/content-configuration",
    "result": {"data":{"post":{"slug":"/content-configuration","title":"Content configuration","date":"16.11.2021","tags":[{"name":"UIKit","slug":"ui-kit"},{"name":"CollectionView","slug":"collection-view"},{"name":"UIContentConfiguration","slug":"ui-content-configuration"}],"description":null,"canonicalUrl":"https://random-blog-about-curses-content.com","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"author\": \"pier\",\n  \"title\": \"Content configuration\",\n  \"date\": \"2021-11-16T00:00:00.000Z\",\n  \"slug\": \"/content-configuration\",\n  \"canonicalUrl\": \"https://random-blog-about-curses-content.com\",\n  \"tags\": [\"UIKit\", \"CollectionView\", \"UIContentConfiguration\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Modern CollectionView applied\"), mdx(\"p\", null, \"We are gonna showcase how we are migrating our cells to the new UIContentConfiguration technique.\"), mdx(\"h2\", null, \"Initial state\"), mdx(\"p\", null, \"Here we see a simple cell we had in our code.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-swift\"\n  }, \"public class SimpleCollectionViewCell: UICollectionViewListCell {\\n\\n    private var titleLabel: UILabel!\\n    private var subtitleLabel: UILabel!\\n    private var photoImageView: UIImageView!\\n    \\n    override init(frame: CGRect) {\\n        super.init(frame: frame)\\n        \\n        /// Layout Code\\n    }\\n    \\n    required init?(coder aDecoder: NSCoder) {\\n        fatalError(\\\"init(coder:) has not been implemented\\\")\\n    }\\n        \\n    override public var isSelected: Bool {\\n        didSet {\\n            if isSelected {\\n                contentView.backgroundColor = .cellSelectionBackgroundColor\\n            } else {\\n                contentView.backgroundColor = .defaultBackgroundColor\\n            }\\n        }\\n    }\\n        \\n    override public var isHighlighted: Bool {\\n        didSet {\\n            contentView.backgroundColor = isHighlighted ? UIColor.systemGray3 : .defaultBackgroundColor\\n        }\\n    }\\n    \\n    public struct ViewModel: Hashable {\\n        public let id: String\\n        public let photo: UIImage\\n        public let title: String\\n        public let subtitle: String?\\n    }\\n    \\n    public func configureFor(viewModel: ViewModel) {\\n        titleLabel.text = viewModel.title\\n        subtitleLabel.text = viewModel.subtitle\\n        photoImageView.image = viewModel.photo\\n    }\\n}\\n\")), mdx(\"p\", null, \"Our custom cell has defines a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ViewModel\"), \", which holds the data we use to render its contents. Whenever we dequeue the cell from the collectionView, we just need to call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"configureFor\"), \" method to properly populate our subviews with the data.\"), mdx(\"p\", null, \"Here we can see how we implement a UICollectionDiffableDataSource, dequeueing this cell:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-swift\"\n  }, \"let simpleCellRegistration = UICollectionView.CellRegistration<SimpleCollectionViewCell, SimpleCollectionViewCell.ViewModel> { (cell, indexPath, vm) in\\n    cell.configureFor(viewModel: vm)\\n}\\n\\nlet dataSource = UICollectionViewDiffableDataSource<Section, Item>.init(collectionView: collectionView) { (cv, indexPath, item) -> UICollectionViewCell? in\\n    switch item {\\n        case .simpleCell(let vm):\\n            return cv.dequeueConfiguredReusableCell(using: simpleCellRegistration, for: indexPath, item: vm)\\n        ...\\n    }\\n}\\n...\\nenum Section {\\n    case onlySection\\n}\\n\\nenum Item: Hashable {\\n    case simpleCell(SimpleCollectionViewCell.ViewModel)\\n}  \\n\")), mdx(\"p\", null, \"We ensure the type passed to the cell is appropriate by making the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Item\"), \" contain that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SimpleCollectionViewCell.ViewModel\"), \", so that when we call the registration handler that type is the ViewModel for this particular item.\"), mdx(\"h2\", null, \"Implementing a custom Configuration\"), mdx(\"p\", null, \"We want to change this ViewModel into the much more powerful and performant \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UIContentConfiguration\"), \", wich will handle not only the data the cell needs (id, photo, title and subtitle), but also the cell state, including our custom-defined properties \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"isSelected\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"isHighlighted\"), \".\"), mdx(\"p\", null, \"Moreover, we want decouple the new view to UICollectionViewCell. This way, we'll have a composable structure that we can reuse elsewhere in our code, if need be.\"), mdx(\"p\", null, \"First we want to take a look at the UIContentConfiguration protocol:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-swift\"\n  }, \"public protocol UIContentConfiguration {\\n\\n    /// Initializes and returns a new instance of the content view using this configuration.\\n    func makeContentView() -> UIView & UIContentView\\n\\n    /// Returns the configuration updated for the specified state, by applying the configuration's default values for that state to any properties that have not been customized.\\n    func updated(for state: UIConfigurationState) -> Self\\n}\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"makeContentView()\"), \" ensures that the configuration creates a new view to serve as a contentView for the cell. This view needs to be both a UIView and a UIContentView, which enforces that the view has a UIContentConfiguration stored. \")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"p\", {\n    parentName: \"li\"\n  }, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"updated(for:)\"), \" returns a new configuration applying a given state to, for example, change the cell background color when the user taps it.\"))), mdx(\"p\", null, \"Our custom configuration will have to implement both functions. We'll define it as follows:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-swift\"\n  }, \"public struct SimpleCellConfiguration: UIContentConfiguration {\\n    public let id: String\\n    public let photo: Photo\\n    public let title: String\\n    public let subtitle: String?\\n    \\n    private(set) var state: UICellConfigurationState?\\n    \\n    public init(id: String, photo: Photo, title: String, subtitle: String?, metadata: [String: AnyHashable]? = nil, titleOverrideColor: UIColor? = nil, replyIconKind: ReplyIconKind = .none, state: UICellConfigurationState? = nil) {\\n        self.id = id\\n        self.photo = photo\\n        self.title = title\\n        self.subtitle = subtitle\\n        self.state = state\\n    }\\n    \\n    public func makeContentView() -> UIView & UIContentView {\\n        View(configuration: self)\\n    }\\n    \\n    public func updated(for state: UIConfigurationState) -> SimpleCell.Configuration {\\n        var mutableCopy = self\\n        if let cellState = state as? UICellConfigurationState {\\n            mutableCopy.state =  cellState\\n        }\\n        return mutableCopy\\n    }\\n    \\n}\\n\")), mdx(\"p\", null, \"Here we can see that we moved all the code in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"ViewModel\"), \" struct into the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Configuration\"), \". We also added the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"state\"), \" property on it, which will hold relevant properties such as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"isSelected\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"isHighlighted\"), \".\"), mdx(\"p\", null, \"Also, you can the UIContentConfiguration functions implemented. They are very straightforward, but note that we must pass \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"self\"), \" to the view, so that it holds the data to configure itself. \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"updated(for:)\"), \" just mutates the configuration, changing its state and returns a fresh copy for te view to be reconfigured.\"), mdx(\"p\", null, \"We also need to define our view. It must be both \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UIView\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UIContentView\"), \". That in turn requires that it has a configuration set in. Furthermore, it will have a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"init(configuration:)\"), \", so that it can be instantiantiated from the makeView() method.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-swift\"\n  }, \"\\npublic class SimpleCellView: UIView & UIContentView {\\n    public var configuration: UIContentConfiguration\\n        \\n    ...\\n    \\n    init(configuration: Configuration) {\\n        self.configuration = configuration\\n        super.init(frame: .zero)\\n        ...\\n        // Layout Code\\n        \\n        configureFor(configuration: configuration)\\n    }\\n}\\n\")), mdx(\"p\", null, \"In the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"init\"), \" method, we'll also include all the layout code the previous SimpleCollectionViewCell had. Note also that here we must configure the view, meaning populating its UILabel, UIImageView, etc. with actual content, which is passed in the init method.\"), mdx(\"p\", null, \"This \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"configureFor(configuration:)\"), \" has basically the same code it had before, but it will also contain the code to style the state changes in the cell\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-swift\"\n  }, \"public func configureFor(configuration: Configuration) {\\n    titleLabel.text = configuration.title\\n    subtitleLabel.text = configuration.subtitle\\n    photoImageView.image = configuration.photo\\n        \\n    if let state = configuration.state {\\n        backgroundColor = {\\n            if state.isSelected {\\n                return .cellSelectionBackgroundColor\\n            } else if state.isHighlighted {\\n                return .systemGray3\\n            } else {\\n                return .defaultBackgroundColor\\n            }\\n        }()\\n    } else {\\n        addShadow()\\n        backgroundColor = .defaultBackgroundColor\\n    }\\n}\\n\")), mdx(\"p\", null, \"Note that here we merged the two properties related to state, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"isSelected\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"isHighlighted\"), \" in a single state change. State now doesn't have to be defined all over the UIView code, and it can be set from one single method.\"), mdx(\"h3\", null, \"How are changes in the configuration affect the view?\"), mdx(\"p\", null, \"So far we saw how we create a cell using the configuration. But if we tap on the cell, the background is not being changed. This is because we lack the last piece of the puzzle: Updates.\"), mdx(\"p\", null, \"As we can see from the updated(for state:) method, we can mutate the configuration whenever a change is needed. This in turn will change the instance of the configuration defined in SimpleCellView. But that does not change any views yet. So we need to set a trigger for that to happen. So we add a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"didSet\"), \" trigger to the SimpleCellView's configuration:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-swift\"\n  }, \"public var configuration: UIContentConfiguration {\\n            didSet {\\n                guard let oldConfig = oldValue as? Configuration,\\n                      let config = configuration as? Configuration else { return }\\n                if oldConfig != config {\\n                    self.configureFor(configuration: config)\\n                }\\n            }\\n        }\\n\")), mdx(\"p\", null, \"Here we make sure that the configuration really changed, so we need SimpleCellConfiguration to conform to Equatable as well. But aside from that, we just need to call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"configureFor(configuration:)\"), \" again to see the change take effect.\"), mdx(\"p\", null, \"And thats really it! Here you can se the complete code.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-swift\"\n  }, \"public enum SimpleCell {\\n    public struct Configuration: UIContentConfiguration {\\n        public let id: String\\n        public let photo: Photo\\n        public let title: String\\n        public let subtitle: String?\\n        \\n        private(set) var state: UICellConfigurationState?\\n        \\n        public init(id: String, photo: Photo, title: String, subtitle: String?, metadata: [String: AnyHashable]? = nil, titleOverrideColor: UIColor? = nil, replyIconKind: ReplyIconKind = .none, state: UICellConfigurationState? = nil) {\\n            self.id = id\\n            self.photo = photo\\n            self.title = title\\n            self.subtitle = subtitle\\n            self.state = state\\n        }\\n        \\n        public func makeContentView() -> UIView & UIContentView {\\n            View(configuration: self)\\n        }\\n        \\n        public func updated(for state: UIConfigurationState) -> SimpleCell.Configuration {\\n            var mutableCopy = self\\n            if let cellState = state as? UICellConfigurationState {\\n                mutableCopy.state =  cellState\\n            }\\n            return mutableCopy\\n        }\\n        \\n    }\\n    \\n    public class View: UIView & UIContentView {\\n        public var configuration: UIContentConfiguration\\n            \\n        ...\\n        \\n        init(configuration: Configuration) {\\n            self.configuration = configuration\\n            super.init(frame: .zero)\\n            ...\\n            // Layout Code\\n            \\n            configureFor(configuration: configuration)\\n        }\\n        \\n        public func configureFor(configuration: Configuration) {\\n            titleLabel.text = configuration.title\\n            subtitleLabel.text = configuration.subtitle\\n            photoImageView.image = configuration.photo\\n                \\n            if let state = configuration.state {\\n                if state.isSelected {\\n                    removeShadow()\\n                } else {\\n                    addVideoaskShadow()\\n                }\\n                backgroundColor = {\\n                    if state.isSelected {\\n                        return .cellSelectionBackgroundColor\\n                    } else if state.isHighlighted {\\n                        return .systemGray3\\n                    } else {\\n                        return .defaultBackgroundColor\\n                    }\\n                }()\\n            } else {\\n                addVideoaskShadow()\\n                backgroundColor = Constants.DefaultBackgroundColor\\n            }\\n        }\\n    }\\n}\\n\")), mdx(\"h3\", null, \"How do we use that in our UICollectionViewDiffableDataSource?\"), mdx(\"p\", null, \"Now with everything in place, our registration and dequeue process looks much like the same as before, but applying the configuration instead:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-swift\"\n  }, \"let simpleCellRegistration = UICollectionView.CellRegistration<UICollectionViewCell, UIContentConfiguration> { (cell, indexPath, configuration) in\\n    cell.configuration = configuration\\n}\\n\\nlet dataSource = UICollectionViewDiffableDataSource<Section, Item>.init(collectionView: collectionView) { (cv, indexPath, item) -> UICollectionViewCell? in\\n    switch item {\\n        case .simpleCell(let configuration):\\n            return cv.dequeueConfiguredReusableCell(using: simpleCellRegistration, for: indexPath, item: configuration)\\n        ...\\n    }\\n}\\n\")), mdx(\"p\", null, \"Here, the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"simpleCellRegistration\"), \" is generic over a plain \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UICollectionViewCell\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UIContentConfiguration\"), \". We don't need to specify any subclass or implementation of those things. So how does that work?\"), mdx(\"p\", null, \"The answer lies in the structure of the DataSource Item. Notice that whenever we call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"cv.dequeueConfiguredReusableCell(using: simpleCellRegistration, for: indexPath, item: configuration)\"), \".\"), mdx(\"p\", null, \"Here we can see the how the Item is now defined:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-swift\"\n  }, \"enum Item: Hashable {\\n    case simpleCell(SimpleCell.Configuration)\\n}    \\n\")), mdx(\"p\", null, \" we pass in a configuration which will be the actual SimpleCell.Configuration we defined previously. It, in turn, will call makeView(), which will create an actual instance of SimpleCell.View. The result of that will be set as the new contentView for the plain UICollectionViewCell that is being dequeued, all without subclassing it. Isn't it nice?\"), mdx(\"p\", null, \"Also, it covers updates on that configuration. In the case for a state change, UIKit will immediatly call SimpleCell.Configuration \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"updated(for state:)\"), \" method, which in turn will update the configuration on the SimpleCell.View and call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"configureFor(configuration:)\"), \", so everything keeps in sync. Moreover, if there's a data change and we need to call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"reconfigureItems()\"), \" on the dataSource, the cell will be dequeued, which will set the configuration again, calling \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"updated(for state:)\"), \".\"), mdx(\"h2\", null, \"Conclusion\"), mdx(\"p\", null, \"With that, is as simple as changing types wherever we used \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SimpleCollectionViewCell\"), \" to the new \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SimpleCell.View\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SimpleCollectionViewCell.ViewModel\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SimpleCell.Configuration\"), \".\"), mdx(\"p\", null, \"And that's it! Using that structure we can now implement the same things we previously had, without the hassle of having all the state properties attached to the view, all while relying on UIKit to do the heavy lifting of deciding when to update content and state.\"));\n}\n;\nMDXContent.isMDXComponent = true;","excerpt":"Modern CollectionView applied We are gonna showcase how we are migrating our cells to the new UIContentConfiguration technique. Initial…","timeToRead":3,"banner":null,"parent":{"frontmatter":{"author":"pier"}}}},"pageContext":{"slug":"/content-configuration","formatString":"DD.MM.YYYY"}},
    "staticQueryHashes": ["2744905544","3090400250","318001574"]}